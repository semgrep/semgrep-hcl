(* Generated by ocaml-tree-sitter. *)

(*
   Disable warning 42:
     "this use of Foo relies on type-directed disambiguation,
     it will not compile with OCaml 4.00 or earlier."
*)
[@@@warning "-42"]

(* Disable warnings against unused variables. *)
[@@@warning "-26-27-32"]

open Tree_sitter_bindings
open Tree_sitter_run

let debug = ref false

type mt = Run.matcher_token

external create_parser :
  unit -> Tree_sitter_API.ts_parser = "octs_create_parser_hcl"

let ts_parser = create_parser ()

let parse_source_string ?src_file contents =
  Tree_sitter_parsing.parse_source_string ?src_file ts_parser contents

let parse_source_file src_file =
  Tree_sitter_parsing.parse_source_file ts_parser src_file

let extras = [
  "comment";
  "whitespace";
]

let children_regexps : (string * Run.exp option) list = [
  "null_lit", None;
  "quoted_template_end", None;
  "block_start", None;
  "semgrep_metavariable", None;
  "heredoc_start",
  Some (
    Alt [|
      Token (Literal "<<");
      Token (Literal "<<-");
    |];
  );
  "pat_b66053b", None;
  "block_end", None;
  "pat_e950a1b", None;
  "object_start", None;
  "template_literal_chunk", None;
  "quoted_template_start", None;
  "function_call_start", None;
  "ellipsis", None;
  "heredoc_identifier", None;
  "strip_marker", None;
  "comma", None;
  "semgrep_ellipsis", None;
  "tuple_end", None;
  "template_interpolation_start", None;
  "pat_780550e", None;
  "semgrep_ellipsis_metavar", None;
  "bool_lit",
  Some (
    Alt [|
      Token (Literal "true");
      Token (Literal "false");
    |];
  );
  "template_interpolation_end", None;
  "tok_choice_pat_3e8fcfc_rep_choice_pat_71519dc", None;
  "function_call_end", None;
  "tuple_start", None;
  "object_end", None;
  "numeric_lit",
  Some (
    Alt [|
      Token (Name "pat_e950a1b");
      Token (Name "pat_b66053b");
    |];
  );
  "template_literal",
  Some (
    Repeat1 (
      Token (Name "template_literal_chunk");
    );
  );
  "legacy_index",
  Some (
    Seq [
      Token (Literal ".");
      Token (Name "pat_780550e");
    ];
  );
  "identifier",
  Some (
    Alt [|
      Token (Name "tok_choice_pat_3e8fcfc_rep_choice_pat_71519dc");
      Token (Name "semgrep_metavariable");
    |];
  );
  "string_lit",
  Some (
    Seq [
      Token (Name "quoted_template_start");
      Token (Name "template_literal");
      Token (Name "quoted_template_end");
    ];
  );
  "get_attr",
  Some (
    Seq [
      Token (Literal ".");
      Token (Name "identifier");
    ];
  );
  "variable_expr", Some (Token (Name "identifier"););
  "literal_value",
  Some (
    Alt [|
      Token (Name "numeric_lit");
      Token (Name "bool_lit");
      Token (Name "null_lit");
      Token (Name "string_lit");
    |];
  );
  "attr_splat",
  Some (
    Seq [
      Token (Literal ".*");
      Repeat (
        Alt [|
          Token (Name "get_attr");
          Token (Name "index");
        |];
      );
    ];
  );
  "binary_operation",
  Some (
    Alt [|
      Seq [
        Token (Name "expr_term");
        Alt [|
          Token (Literal "*");
          Token (Literal "/");
          Token (Literal "%");
        |];
        Token (Name "expr_term");
      ];
      Seq [
        Token (Name "expr_term");
        Alt [|
          Token (Literal "+");
          Token (Literal "-");
        |];
        Token (Name "expr_term");
      ];
      Seq [
        Token (Name "expr_term");
        Alt [|
          Token (Literal ">");
          Token (Literal ">=");
          Token (Literal "<");
          Token (Literal "<=");
        |];
        Token (Name "expr_term");
      ];
      Seq [
        Token (Name "expr_term");
        Alt [|
          Token (Literal "==");
          Token (Literal "!=");
        |];
        Token (Name "expr_term");
      ];
      Seq [
        Token (Name "expr_term");
        Alt [|
          Token (Literal "&&");
        |];
        Token (Name "expr_term");
      ];
      Seq [
        Token (Name "expr_term");
        Alt [|
          Token (Literal "||");
        |];
        Token (Name "expr_term");
      ];
    |];
  );
  "collection_value",
  Some (
    Alt [|
      Token (Name "tuple");
      Token (Name "object");
    |];
  );
  "conditional",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "?");
      Token (Name "expression");
      Token (Literal ":");
      Token (Name "expression");
    ];
  );
  "deep_ellipsis",
  Some (
    Seq [
      Token (Literal "<...");
      Token (Name "expression");
      Token (Literal "...>");
    ];
  );
  "expr_term",
  Some (
    Alt [|
      Alt [|
        Token (Name "literal_value");
        Token (Name "template_expr");
        Token (Name "collection_value");
        Token (Name "variable_expr");
        Token (Name "function_call");
        Token (Name "for_expr");
        Token (Name "operation");
        Seq [
          Token (Name "expr_term");
          Token (Name "index");
        ];
        Seq [
          Token (Name "expr_term");
          Token (Name "get_attr");
        ];
        Seq [
          Token (Name "expr_term");
          Token (Name "splat");
        ];
        Seq [
          Token (Literal "(");
          Token (Name "expression");
          Token (Literal ")");
        ];
      |];
      Token (Name "semgrep_ellipsis");
      Token (Name "deep_ellipsis");
      Token (Name "semgrep_ellipsis_metavar");
    |];
  );
  "expression",
  Some (
    Alt [|
      Token (Name "expr_term");
      Token (Name "conditional");
    |];
  );
  "for_cond",
  Some (
    Seq [
      Token (Literal "if");
      Token (Name "expression");
    ];
  );
  "for_expr",
  Some (
    Alt [|
      Token (Name "for_tuple_expr");
      Token (Name "for_object_expr");
    |];
  );
  "for_intro",
  Some (
    Seq [
      Token (Literal "for");
      Token (Name "identifier");
      Opt (
        Seq [
          Token (Literal ",");
          Token (Name "identifier");
        ];
      );
      Token (Literal "in");
      Token (Name "expression");
      Token (Literal ":");
    ];
  );
  "for_object_expr",
  Some (
    Seq [
      Token (Name "object_start");
      Token (Name "for_intro");
      Token (Name "expression");
      Token (Literal "=>");
      Token (Name "expression");
      Opt (
        Token (Name "ellipsis");
      );
      Opt (
        Token (Name "for_cond");
      );
      Token (Name "object_end");
    ];
  );
  "for_tuple_expr",
  Some (
    Seq [
      Token (Name "tuple_start");
      Token (Name "for_intro");
      Token (Name "expression");
      Opt (
        Token (Name "for_cond");
      );
      Token (Name "tuple_end");
    ];
  );
  "full_splat",
  Some (
    Seq [
      Token (Literal "[*]");
      Repeat (
        Alt [|
          Token (Name "get_attr");
          Token (Name "index");
        |];
      );
    ];
  );
  "function_arguments",
  Some (
    Seq [
      Token (Name "expression");
      Repeat (
        Seq [
          Token (Name "comma");
          Token (Name "expression");
        ];
      );
      Opt (
        Alt [|
          Token (Literal ",");
          Token (Name "ellipsis");
        |];
      );
    ];
  );
  "function_call",
  Some (
    Seq [
      Token (Name "identifier");
      Token (Name "function_call_start");
      Opt (
        Token (Name "function_arguments");
      );
      Token (Name "function_call_end");
    ];
  );
  "heredoc_template",
  Some (
    Seq [
      Token (Name "heredoc_start");
      Token (Name "heredoc_identifier");
      Opt (
        Repeat (
          Alt [|
            Token (Name "template_literal");
            Token (Name "template_interpolation");
          |];
        );
      );
      Token (Name "heredoc_identifier");
    ];
  );
  "index",
  Some (
    Alt [|
      Token (Name "new_index");
      Token (Name "legacy_index");
    |];
  );
  "new_index",
  Some (
    Seq [
      Token (Literal "[");
      Token (Name "expression");
      Token (Literal "]");
    ];
  );
  "object",
  Some (
    Seq [
      Token (Name "object_start");
      Opt (
        Token (Name "object_elems");
      );
      Token (Name "object_end");
    ];
  );
  "object_elem",
  Some (
    Alt [|
      Seq [
        Token (Name "expression");
        Alt [|
          Token (Literal "=");
          Token (Literal ":");
        |];
        Token (Name "expression");
      ];
      Token (Name "semgrep_ellipsis");
      Token (Name "semgrep_ellipsis_metavar");
    |];
  );
  "object_elems",
  Some (
    Seq [
      Token (Name "object_elem");
      Repeat (
        Seq [
          Opt (
            Token (Name "comma");
          );
          Token (Name "object_elem");
        ];
      );
      Opt (
        Token (Name "comma");
      );
    ];
  );
  "operation",
  Some (
    Alt [|
      Token (Name "unary_operation");
      Token (Name "binary_operation");
    |];
  );
  "quoted_template",
  Some (
    Seq [
      Token (Name "quoted_template_start");
      Opt (
        Repeat (
          Alt [|
            Token (Name "template_literal");
            Token (Name "template_interpolation");
          |];
        );
      );
      Token (Name "quoted_template_end");
    ];
  );
  "splat",
  Some (
    Alt [|
      Token (Name "attr_splat");
      Token (Name "full_splat");
    |];
  );
  "template_expr",
  Some (
    Alt [|
      Token (Name "quoted_template");
      Token (Name "heredoc_template");
    |];
  );
  "template_interpolation",
  Some (
    Seq [
      Token (Name "template_interpolation_start");
      Opt (
        Token (Name "strip_marker");
      );
      Opt (
        Token (Name "expression");
      );
      Opt (
        Token (Name "strip_marker");
      );
      Token (Name "template_interpolation_end");
    ];
  );
  "tuple",
  Some (
    Seq [
      Token (Name "tuple_start");
      Opt (
        Token (Name "tuple_elems");
      );
      Token (Name "tuple_end");
    ];
  );
  "tuple_elems",
  Some (
    Seq [
      Token (Name "expression");
      Repeat (
        Seq [
          Token (Name "comma");
          Token (Name "expression");
        ];
      );
      Opt (
        Token (Name "comma");
      );
    ];
  );
  "unary_operation",
  Some (
    Seq [
      Alt [|
        Token (Literal "-");
        Token (Literal "!");
      |];
      Token (Name "expr_term");
    ];
  );
  "attribute",
  Some (
    Seq [
      Token (Name "identifier");
      Token (Literal "=");
      Token (Name "expression");
    ];
  );
  "semgrep_expression",
  Some (
    Seq [
      Token (Literal "__SEMGREP_EXPRESSION");
      Token (Name "expression");
    ];
  );
  "block",
  Some (
    Seq [
      Token (Name "identifier");
      Repeat (
        Alt [|
          Token (Name "string_lit");
          Token (Name "identifier");
        |];
      );
      Token (Name "block_start");
      Opt (
        Token (Name "body");
      );
      Token (Name "block_end");
    ];
  );
  "body",
  Some (
    Repeat1 (
      Alt [|
        Token (Name "attribute");
        Token (Name "block");
        Token (Name "semgrep_ellipsis");
        Token (Name "semgrep_ellipsis_metavar");
      |];
    );
  );
  "config_file",
  Some (
    Alt [|
      Opt (
        Alt [|
          Token (Name "body");
          Token (Name "object");
        |];
      );
      Token (Name "semgrep_expression");
    |];
  );
]

let trans_null_lit ((kind, body) : mt) : CST.null_lit =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_quoted_template_end ((kind, body) : mt) : CST.quoted_template_end =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_block_start ((kind, body) : mt) : CST.block_start =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_semgrep_metavariable ((kind, body) : mt) : CST.semgrep_metavariable =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_heredoc_start ((kind, body) : mt) : CST.heredoc_start =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `LTLT (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `LTLTDASH (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_pat_b66053b ((kind, body) : mt) : CST.pat_b66053b =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_block_end ((kind, body) : mt) : CST.block_end =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_e950a1b ((kind, body) : mt) : CST.pat_e950a1b =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_object_start ((kind, body) : mt) : CST.object_start =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_template_literal_chunk ((kind, body) : mt) : CST.template_literal_chunk =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_quoted_template_start ((kind, body) : mt) : CST.quoted_template_start =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_function_call_start ((kind, body) : mt) : CST.function_call_start =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_ellipsis ((kind, body) : mt) : CST.ellipsis =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_heredoc_identifier ((kind, body) : mt) : CST.heredoc_identifier =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_strip_marker ((kind, body) : mt) : CST.strip_marker =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_comma ((kind, body) : mt) : CST.comma =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_semgrep_ellipsis ((kind, body) : mt) : CST.semgrep_ellipsis =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_tuple_end ((kind, body) : mt) : CST.tuple_end =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_template_interpolation_start ((kind, body) : mt) : CST.template_interpolation_start =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_780550e ((kind, body) : mt) : CST.pat_780550e =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_semgrep_ellipsis_metavar ((kind, body) : mt) : CST.semgrep_ellipsis_metavar =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_bool_lit ((kind, body) : mt) : CST.bool_lit =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `True (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `False (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_template_interpolation_end ((kind, body) : mt) : CST.template_interpolation_end =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_tok_choice_pat_3e8fcfc_rep_choice_pat_71519dc ((kind, body) : mt) : CST.tok_choice_pat_3e8fcfc_rep_choice_pat_71519dc =
  match body with
  | Leaf v -> v
  | Children _ -> assert false


let trans_function_call_end ((kind, body) : mt) : CST.function_call_end =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_tuple_start ((kind, body) : mt) : CST.tuple_start =
  match body with
  | Leaf v -> v
  | Children _ -> assert false


let trans_object_end ((kind, body) : mt) : CST.object_end =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_numeric_lit ((kind, body) : mt) : CST.numeric_lit =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pat_e950a1b (
            trans_pat_e950a1b (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Pat_b66053b (
            trans_pat_b66053b (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_template_literal ((kind, body) : mt) : CST.template_literal =
  match body with
  | Children v ->
      Run.repeat1
        (fun v ->
          trans_template_literal_chunk (Run.matcher_token v)
        )
        v
  | Leaf _ -> assert false

let trans_legacy_index ((kind, body) : mt) : CST.legacy_index =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_pat_780550e (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_identifier ((kind, body) : mt) : CST.identifier =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Tok_choice_pat_3e8fcfc_rep_choice_pat_71519dc (
            trans_tok_choice_pat_3e8fcfc_rep_choice_pat_71519dc (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Semg_meta (
            trans_semgrep_metavariable (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_string_lit ((kind, body) : mt) : CST.string_lit =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_quoted_template_start (Run.matcher_token v0),
            trans_template_literal (Run.matcher_token v1),
            trans_quoted_template_end (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_get_attr ((kind, body) : mt) : CST.get_attr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_variable_expr ((kind, body) : mt) : CST.variable_expr =
  match body with
  | Children v ->
      trans_identifier (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_literal_value ((kind, body) : mt) : CST.literal_value =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Nume_lit (
            trans_numeric_lit (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Bool_lit (
            trans_bool_lit (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Null_lit (
            trans_null_lit (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Str_lit (
            trans_string_lit (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_attr_splat ((kind, body) : mt) : CST.attr_splat =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Get_attr (
                      trans_get_attr (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Index (
                      trans_index (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_binary_operation ((kind, body) : mt) : CST.binary_operation =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Expr_term_choice_STAR_expr_term (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expr_term (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `STAR (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `SLASH (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (2, v) ->
                      `PERC (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_expr_term (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Expr_term_choice_PLUS_expr_term (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expr_term (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `PLUS (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `DASH (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_expr_term (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Expr_term_choice_GT_expr_term (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expr_term (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `GT (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `GTEQ (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (2, v) ->
                      `LT (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (3, v) ->
                      `LTEQ (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_expr_term (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (3, v) ->
          `Expr_term_choice_EQEQ_expr_term (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expr_term (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `EQEQ (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `BANGEQ (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_expr_term (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (4, v) ->
          `Expr_term_choice_AMPAMP_expr_term (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expr_term (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `AMPAMP (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_expr_term (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (5, v) ->
          `Expr_term_choice_BARBAR_expr_term (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expr_term (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `BARBAR (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_expr_term (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_collection_value ((kind, body) : mt) : CST.collection_value =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Tuple (
            trans_tuple (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Obj (
            trans_object_ (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_conditional ((kind, body) : mt) : CST.conditional =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_expression (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_deep_ellipsis ((kind, body) : mt) : CST.deep_ellipsis =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_expr_term ((kind, body) : mt) : CST.expr_term =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_lit_value (
            (match v with
            | Alt (0, v) ->
                `Lit_value (
                  trans_literal_value (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Temp_expr (
                  trans_template_expr (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Coll_value (
                  trans_collection_value (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Var_expr (
                  trans_variable_expr (Run.matcher_token v)
                )
            | Alt (4, v) ->
                `Func_call (
                  trans_function_call (Run.matcher_token v)
                )
            | Alt (5, v) ->
                `For_expr (
                  trans_for_expr (Run.matcher_token v)
                )
            | Alt (6, v) ->
                `Oper (
                  trans_operation (Run.matcher_token v)
                )
            | Alt (7, v) ->
                `Expr_term_index (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_expr_term (Run.matcher_token v0),
                        trans_index (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (8, v) ->
                `Expr_term_get_attr (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_expr_term (Run.matcher_token v0),
                        trans_get_attr (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (9, v) ->
                `Expr_term_splat (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        trans_expr_term (Run.matcher_token v0),
                        trans_splat (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (10, v) ->
                `LPAR_exp_RPAR (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        trans_expression (Run.matcher_token v1),
                        Run.trans_token (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Semg_ellips (
            trans_semgrep_ellipsis (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Deep_ellips (
            trans_deep_ellipsis (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Semg_ellips_meta (
            trans_semgrep_ellipsis_metavar (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_expression ((kind, body) : mt) : CST.expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Expr_term (
            trans_expr_term (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Cond (
            trans_conditional (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_for_cond ((kind, body) : mt) : CST.for_cond =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_for_expr ((kind, body) : mt) : CST.for_expr =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `For_tuple_expr (
            trans_for_tuple_expr (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `For_obj_expr (
            trans_for_object_expr (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_for_intro ((kind, body) : mt) : CST.for_intro =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_identifier (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3),
            trans_expression (Run.matcher_token v4),
            Run.trans_token (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_for_object_expr ((kind, body) : mt) : CST.for_object_expr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6; v7] ->
          (
            trans_object_start (Run.matcher_token v0),
            trans_for_intro (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_expression (Run.matcher_token v4),
            Run.opt
              (fun v -> trans_ellipsis (Run.matcher_token v))
              v5
            ,
            Run.opt
              (fun v -> trans_for_cond (Run.matcher_token v))
              v6
            ,
            trans_object_end (Run.matcher_token v7)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_for_tuple_expr ((kind, body) : mt) : CST.for_tuple_expr =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_tuple_start (Run.matcher_token v0),
            trans_for_intro (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.opt
              (fun v -> trans_for_cond (Run.matcher_token v))
              v3
            ,
            trans_tuple_end (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_full_splat ((kind, body) : mt) : CST.full_splat =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Get_attr (
                      trans_get_attr (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Index (
                      trans_index (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_function_arguments ((kind, body) : mt) : CST.function_arguments =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_comma (Run.matcher_token v0),
                      trans_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `COMMA (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Ellips (
                      trans_ellipsis (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_function_call ((kind, body) : mt) : CST.function_call =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_identifier (Run.matcher_token v0),
            trans_function_call_start (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_function_arguments (Run.matcher_token v))
              v2
            ,
            trans_function_call_end (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_heredoc_template ((kind, body) : mt) : CST.heredoc_template =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_heredoc_start (Run.matcher_token v0),
            trans_heredoc_identifier (Run.matcher_token v1),
            Run.opt
              (fun v ->
                Run.repeat
                  (fun v ->
                    (match v with
                    | Alt (0, v) ->
                        `Temp_lit (
                          trans_template_literal (Run.matcher_token v)
                        )
                    | Alt (1, v) ->
                        `Temp_interp (
                          trans_template_interpolation (Run.matcher_token v)
                        )
                    | _ -> assert false
                    )
                  )
                  v
              )
              v2
            ,
            trans_heredoc_identifier (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_index ((kind, body) : mt) : CST.index =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `New_index (
            trans_new_index (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Legacy_index (
            trans_legacy_index (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_new_index ((kind, body) : mt) : CST.new_index =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_object_ ((kind, body) : mt) : CST.object_ =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_object_start (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_object_elems (Run.matcher_token v))
              v1
            ,
            trans_object_end (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_object_elem ((kind, body) : mt) : CST.object_elem =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Exp_choice_EQ_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_expression (Run.matcher_token v0),
                  (match v1 with
                  | Alt (0, v) ->
                      `EQ (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `COLON (
                        Run.trans_token (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Semg_ellips (
            trans_semgrep_ellipsis (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Semg_ellips_meta (
            trans_semgrep_ellipsis_metavar (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_object_elems ((kind, body) : mt) : CST.object_elems =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_object_elem (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.opt
                        (fun v -> trans_comma (Run.matcher_token v))
                        v0
                      ,
                      trans_object_elem (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> trans_comma (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_operation ((kind, body) : mt) : CST.operation =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Un_oper (
            trans_unary_operation (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Bin_oper (
            trans_binary_operation (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_quoted_template ((kind, body) : mt) : CST.quoted_template =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_quoted_template_start (Run.matcher_token v0),
            Run.opt
              (fun v ->
                Run.repeat
                  (fun v ->
                    (match v with
                    | Alt (0, v) ->
                        `Temp_lit (
                          trans_template_literal (Run.matcher_token v)
                        )
                    | Alt (1, v) ->
                        `Temp_interp (
                          trans_template_interpolation (Run.matcher_token v)
                        )
                    | _ -> assert false
                    )
                  )
                  v
              )
              v1
            ,
            trans_quoted_template_end (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_splat ((kind, body) : mt) : CST.splat =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Attr_splat (
            trans_attr_splat (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Full_splat (
            trans_full_splat (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_template_expr ((kind, body) : mt) : CST.template_expr =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Quoted_temp (
            trans_quoted_template (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Here_temp (
            trans_heredoc_template (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_template_interpolation ((kind, body) : mt) : CST.template_interpolation =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_template_interpolation_start (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_strip_marker (Run.matcher_token v))
              v1
            ,
            Run.opt
              (fun v -> trans_expression (Run.matcher_token v))
              v2
            ,
            Run.opt
              (fun v -> trans_strip_marker (Run.matcher_token v))
              v3
            ,
            trans_template_interpolation_end (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_tuple ((kind, body) : mt) : CST.tuple =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_tuple_start (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_tuple_elems (Run.matcher_token v))
              v1
            ,
            trans_tuple_end (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_tuple_elems ((kind, body) : mt) : CST.tuple_elems =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_comma (Run.matcher_token v0),
                      trans_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> trans_comma (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_unary_operation ((kind, body) : mt) : CST.unary_operation =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `DASH (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `BANG (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_expr_term (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_attribute ((kind, body) : mt) : CST.attribute =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_semgrep_expression ((kind, body) : mt) : CST.semgrep_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_block ((kind, body) : mt) : CST.block =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Str_lit (
                      trans_string_lit (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Id (
                      trans_identifier (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            trans_block_start (Run.matcher_token v2),
            Run.opt
              (fun v -> trans_body (Run.matcher_token v))
              v3
            ,
            trans_block_end (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_body ((kind, body) : mt) : CST.body =
  match body with
  | Children v ->
      Run.repeat1
        (fun v ->
          (match v with
          | Alt (0, v) ->
              `Attr (
                trans_attribute (Run.matcher_token v)
              )
          | Alt (1, v) ->
              `Blk (
                trans_block (Run.matcher_token v)
              )
          | Alt (2, v) ->
              `Semg_ellips (
                trans_semgrep_ellipsis (Run.matcher_token v)
              )
          | Alt (3, v) ->
              `Semg_ellips_meta (
                trans_semgrep_ellipsis_metavar (Run.matcher_token v)
              )
          | _ -> assert false
          )
        )
        v
  | Leaf _ -> assert false

let trans_config_file ((kind, body) : mt) : CST.config_file =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Opt_choice_body (
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Body (
                      trans_body (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Obj (
                      trans_object_ (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v
          )
      | Alt (1, v) ->
          `Semg_exp (
            trans_semgrep_expression (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let parse_input_tree input_tree =
  let orig_root_node = Tree_sitter_parsing.root input_tree in
  let src = Tree_sitter_parsing.src input_tree in
  let errors = Run.extract_errors src orig_root_node in
  let root_node = Run.remove_extras ~extras orig_root_node in
  let matched_tree = Run.match_tree children_regexps src root_node in
  let opt_program = Option.map trans_config_file matched_tree in
  Parsing_result.create src opt_program errors

let string ?src_file contents =
  let input_tree = parse_source_string ?src_file contents in
  parse_input_tree input_tree

let file src_file =
  let input_tree = parse_source_file src_file in
  parse_input_tree input_tree

